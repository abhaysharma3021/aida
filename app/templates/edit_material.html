{% extends "base.html" %}

{% block title %}Edit {{ material_type|replace('_', ' ')|title }} - Module {{ module_id }}{% endblock %}

{% block header_subtitle %}Edit Material{% endblock %}

{% block content %}
<div class="container mt-4">
    <div class="row mb-4">
        <div class="col-md-8">
            <h3 class="mb-2">Edit {{ material_type|replace('_', ' ')|title }}</h3>
            <p class="text-muted">Module {{ module_id }} - Make changes to the material content below</p>
        </div>
        <div class="col-md-4 text-md-end">
            <a href="{{ url_for('main.view_material', analysis_id=analysis_id, module_id=module_id, material_type=material_type) }}" 
               class="btn btn-secondary">
                <i class="fas fa-arrow-left"></i> Back to Material
            </a>
        </div>
    </div>

    <form method="POST">
        <div class="row">
            <div class="col-lg-9">
                <div class="card">
                    <div class="card-header bg-warning text-dark">
                        <h5 class="mb-0">
                            <i class="fas fa-edit"></i> Material Content
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="material_content" class="form-label">Content (Markdown Format)</label>
                             <!-- <textarea class="form-control" id="material_content" name="material_content" rows="25">{{ material_content }}</textarea>  -->
   <div class="editor-container">
    <div class="toolbar">
        <img id="viewSourceBtn" src="/static/MS-Learning-icons/icon-view-source-code.png" alt="View Source Code" title="View Source Code" style="cursor: pointer; padding: 10px;">
        <img id="viewPreviewBtn" src="/static/MS-Learning-icons/icon-file-preview.png" alt="View Preview" title="View Preview" style="cursor: pointer; padding: 10px">
        <!-- <img id="viewFileBtn" src="/static/MS-Learning-icons/icon-refresh.png" alt="View File" title="Refresh" style="cursor: pointer; padding: 9px; width: 22px; height: 17px;"> -->
        <!-- <img id="save" src="/static/MS-Learning-icons/icon-save.png" alt="Save" title="Save" onclick="saveMarkdownContent()" style="cursor: pointer; padding: 10px"> -->
        <select name="headings" id="headingDropdown">
            <option value="normal" style="font-size: 0.8em;" selected="">Select Heading</option>
            <option value="heading1" style="font-size: 1.6em;">Heading 1</option>
            <option value="heading2" style="font-size: 1.4em;">Heading 2</option>
            <option value="heading3" style="font-size: 1.2em;">Heading 3</option>
            <option value="heading4" style="font-size: 1em;">Heading 4</option>
            <option value="normal" style="font-size: 0.8em;">Normal</option>
        </select>
        <img src="/static/MS-Learning-icons/icon-bold.png" class="fa-solid imgBold" data-action="bold" title="Bold" style="cursor: pointer;" alt="Bold">
        <img src="/static/MS-Learning-icons/icon-ltalic.png" class="fa-solid imgItalic" data-action="italic" title="Italic" style="cursor: pointer;" alt="Italic">
        <img src="/static/MS-Learning-icons/icon-underline.png" class="fa-solid imgUnderline" data-action="underline" title="Underline" style="cursor: pointer;" alt="Underline">
        <!-- <img src="/static/MS-Learning-icons/icon-link.png" class="fa-solid imgLink" data-action="link" title="Link" style="cursor: pointer;" alt="Link"> -->
        <!-- <img src="/static/MS-Learning-icons/icon-image.png" class="fa-solid imgImage" title="Image" style="cursor: pointer;" alt="Image"> -->
		<img src="/static/MS-Learning-icons/icon-link.png" class="fa-solid  disabled-imgs" data-action="link" title="This option is currently not supported" alt="Link">
        <img src="/static/MS-Learning-icons/icon-image.png" class="fa-solid  disabled-imgs" title="This option is currently not supported"  alt="Image">																																									   
        <img id="unorderedListBtn" class="fa-solid" src="/static/MS-Learning-icons/icon-bullet.png" title="Bullets" style="cursor: pointer;" alt="Bullets">
        <img id="orderedListBtn" class="fa-solid" src="/static/MS-Learning-icons/icon-numbering.png" title="Numbering" style="cursor: pointer;" alt="Numbering">
        <img id="increaseIndentBtn" class="fa-solid" src="/static/MS-Learning-icons/icon-indent.png" title="Increase Indent" style="cursor: pointer;" alt="Indent">
        <!-- <img id="ctable" class="fa-solid" src="/static/MS-Learning-icons/icon-table.png" title="Table" style="cursor: pointer;" alt="Table"> -->
		<img id="" class="fa-solid disabled-imgs" src="/static/MS-Learning-icons/icon-table.png" title="This option is currently not supported" style="cursor: pointer;" alt="Table">																																									   
		<img src="/static/MS-Learning-icons/new-line.png" id="insertNewlineBtn" title="Format" alt="Format Line" style="cursor: pointer; padding: 10px;">
		
   </div>
    <div class="imagepopup">
        <div><p>Enter Image Path:</p></div>
        <input type="text" id="imagelink">
        <div>
            <i class="fa-solid fa-check" id="savepath" style="position: unset; border: 1px solid #ccc;"></i>
            <i class="fa-solid fa-x" style="position: unset; border: 1px solid #ccc;"></i>
        </div>
        <i class="fa-solid fas fa-x"></i>
    </div>
    <div class="linkpopup">
        <div><p>Enter Link:</p></div>
        <input type="url" id="linkin">
        <div>
            <i class="fa-solid fa-check" id="savelink" style="position: unset; border: 1px solid #ccc;"></i>
            <i class="fa-solid fa-x" style="position: unset; border: 1px solid #ccc;"></i>
        </div>
        <i class="fa-solid fas fa-x"></i>
    </div>
    <div class="tablepopup">
        <div><p>Enter number of rows:</p></div>
        <input type="number" id="numRows" min="1">
        <div><p>Enter number of columns:</p></div>
        <input type="number" id="numCols" min="1">
        <div>
            <i class="fa-solid fa-check" id="createTable" style="position: unset; border: 1px solid #ccc;"></i>
            <i class="fa-solid fa-x" style="position: unset; border: 1px solid #ccc;"></i>
        </div>
        <i class="fa-solid fas fa-x"></i>
    </div>
    <textarea class="form-control" id="material_content"  name="material_content" rows="25">{{ material_content}}</textarea>
     <!-- <textarea class="form-control" id="material_content" name="material_content" rows="25">{{ material_content }}</textarea> -->
    <div id="preview" class="preview"></div>
    <div id="file" class="file"></div>
</div>
                            <div class="form-text">
                                Use Markdown formatting for headings (#), bold (**text**), lists (- item), etc.
                            </div>
                        </div>
                        
                        <div class="d-flex justify-content-between">
                            <button type="submit" id="saveBtn" class="btn btn-primary">
                                <i class="fas fa-save"></i> Save Changes
                            </button>
                            <button type="button" id="previewBtn" class="btn btn-info">
                                <i class="fas fa-eye"></i> Preview
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-lg-3">
                <!-- Markdown Help Card -->
                <div class="card mb-4">
                    <div class="card-header bg-info text-white">
                        <h6 class="mb-0">Markdown Help</h6>
                    </div>
                    <div class="card-body">
                        <ul class="list-group list-group-flush">
                            <li class="list-group-item"><code># Heading 1</code></li>
                            <li class="list-group-item"><code>## Heading 2</code></li>
                            <li class="list-group-item"><code>### Heading 3</code></li>
                            <li class="list-group-item"><code>**bold text**</code></li>
                            <li class="list-group-item"><code>*italic text*</code></li>
                            <li class="list-group-item"><code>- Bullet point</code></li>
                            <li class="list-group-item"><code>1. Numbered list</code></li>
                            <li class="list-group-item"><code>`code`</code></li>
                        </ul>
                    </div>
                </div>
                
                <!-- Material Type Info -->
                <div class="card">
                    <div class="card-header bg-secondary text-white">
                        <h6 class="mb-0">Material Information</h6>
                    </div>
                    <div class="card-body">
                        <p><strong>Type:</strong> {{ material_type|replace('_', ' ')|title }}</p>
                        <p><strong>Module:</strong> {{ module_id }}</p>
                        <p class="mb-0"><strong>Format:</strong> Markdown</p>
                    </div>
                </div>
            </div>
        </div>
    </form>
</div>

<!-- Preview Modal -->
<div class="modal fade" id="previewModal" tabindex="-1" aria-labelledby="previewModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="previewModalLabel">Material Preview</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="preview-content" class="material-preview"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<style>
.material-preview {
    font-family: Georgia, serif;
    line-height: 1.7;
    color: #333;
}

.material-preview h1, .material-preview h2, .material-preview h3,
.material-preview h4, .material-preview h5, .material-preview h6 {
    color: #2c3e50;
    margin-top: 1.5rem;
    margin-bottom: 0.5rem;
}

.material-preview p {
    margin-bottom: 1rem;
}

.material-preview ul, .material-preview ol {
    margin-bottom: 1rem;
    padding-left: 2rem;
}

.material-preview blockquote {
    border-left: 4px solid #007bff;
    padding-left: 1rem;
    margin: 1rem 0;
    font-style: italic;
    color: #6c757d;
}

.material-preview code {
    background: #f8f9fa;
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
}

.material-preview pre {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 6px;
    overflow-x: auto;
}
</style>
<style>
      
            .editor-container {
                width: 100%;
                height: 100vh;
                display: flex;
                flex-direction: column;
                /* border: 1px solid #ccc; */
                background-color: white;
            }
            .toolbar {
                padding: 4px;
                display: flex;
                justify-content: flex-start;
                border: 1px solid #ccc;
                gap: 4px;
                border-bottom: none;
				 flex-wrap: wrap;
            }
            .toolbar button {
                padding: 5px 10px;
                /* margin-right: 10px; */
                cursor: pointer;
                background-color: #166fd4;
                color: white;
                border: none;
                border-radius: 3px;
                font-size: 16px;
            }
            textarea, .preview {
                flex-grow: 1;
                padding: 15px;
                border: 1px solid #ccc;
                font-size: 16px;
                width: 100%;
                height: 100%;
                box-sizing: border-box;
                resize: none;
            }
            textarea {
                display: block;
            }
            .preview, .file {
                display: none;
                overflow-y: auto;
                background-color: #f9f9f9;
                font-family: 'Segoe UI' !important;
                line-height: 1.6;
            }
            ul ul {
                margin-left: 20px;
            }
            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
                white-space: nowrap;
            }
            th {
                background-color: #f2f2f2;
            }
            i {
                /* margin: 10px; */
                font-size: 16px;
            }
            select {
                padding: 5px 100px 5px 7px;
                /* margin-right: 10px; */
                cursor: pointer;
                border-radius: 3px;
                font-size: 16px;
            }
            select:focus {
                outline: none; /* Removes the default focus outline */
                border-color: inherit; /* Keeps the border color consistent */
                box-shadow: none; /* Removes any focus-related shadows */
                border-bottom: 2px solid #0f6cbd;
            }
            option {
                background-color: #ffff;
                color: black;
            }
            .linkpopup, .imagepopup, .tablepopup {
                display: none;
                flex-direction: column;
                align-items: flex-start !important;
                position: fixed; /* Center it relative to the viewport */
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%); /* Center alignment */
                border: none;
                border-radius: 4px;
                width: 360px; /* Adjust width as needed for your popups */
                background-color: white;
                align-items: center;
                /* gap: 12px; */
                padding: 20px;
                box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
                z-index: 1000; /* Ensure it is on top of other elements */
            }

            .linkpopup button, .imagepopup button, .tablepopup button {
                padding: 10px 18px;
                background: #0078d4;
                color: white;
                border: none;
                border-radius: 3px;
            }

            .tablepopup {
                width: 200px;
                /* height: 80%; */
            }

            .linkpopup i, .imagepopup i, .tablepopup i {
                position: absolute; /* Position close button within the popup */
                top: 2px; /* Top-right corner */
                right: 2px;
                cursor: pointer;
                font-size: 16px;
                color: #666; /* Adjust color for the close button */
                transition: color 0.3s ease;
            }

            .linkpopup i:hover, .imagepopup i:hover, .tablepopup i:hover {
                color: #0078d4; /* Highlight the close button on hover */
            }

            /* Ensure proper styling for the input boxes */
            .linkpopup input, .imagepopup input, .tablepopup input {
                width: 92%;
                /* box-sizing: border-box; */
                padding: 8px;
                /* margin-bottom: 10px; */
                border: 1px solid #ccc;
                border-radius: 3px;
                font-size: 14px;
                margin-bottom: 16px;
            }

            .linkpopup input:focus, .imagepopup input:focus, .tablepopup input:focus {
                /* border: none; */
                outline: none;
            }

            /* Add a semi-transparent overlay */
            .overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5); /* Dark transparent background */
                z-index: 999; /* Below the popup */
                display: none; /* Initially hidden */
            }

            .preview {
                white-space: pre; /* Preserve whitespace, including line breaks */
                /* word-break: break-word; 
                overflow-wrap: break-word;  */
                text-wrap-mode: wrap;
            }
            select {
                border-color: #ccc;
            }
            .fa-solid {
                padding: 10px;
                /* margin-right: 10px; */
                /* border: 1px solid black; Add a border */
                border-radius: 3px; /* Round the corners */
                cursor: pointer;
                /* background-color: white; Initial background color */
                transition: background-color 0.3s ease, color 0.3s ease; /* Smooth hover transition */
            }
            .fa-solid:hover {
                background-color: #f0f0f0; /* Background color on hover */
                color: inherit; /* Keep icon color consistent */
            }
            textarea {
                border: 1px solid #ccc; /* Default border */
                /* border-top: none; */
            }

            textarea:focus {
                outline: none;
                border-color: #0078d4; /* Changes border color on focus */
                /* border-top: none; */
            }
            .toolbar img {
                height: 40px;
                width: 40px;
            }
            iframe #WebResource_new_Markdown {
                border: none !important;
            }
            custompre {
                
                border-radius: 6px;
                overflow-x: auto;
            }
            custompre customcode {
                
                border-radius: 3px;
                font-family: 'Courier New', monospace;
            }
			.disabled-imgs{
                opacity: 0.5;
                cursor: unset  !important;
                              
            }
            .disabled-imgs:hover{
                background-color: unset !important; 
								   
													  
            }
        </style>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>

document.getElementById('material_content').addEventListener('click', function() {
     document.getElementById('headingDropdown').selectedIndex = 0;
});

document.addEventListener('DOMContentLoaded', function() {
    // Auto-resize textarea
    var textarea = document.getElementById('material_content');
    textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });
    
    // Initialize height
    textarea.style.height = (textarea.scrollHeight) + 'px';
    
    // Preview functionality
    document.getElementById('previewBtn').addEventListener('click', function() {
        var content = document.getElementById('material_content').value;
        var previewContent = document.getElementById('preview-content');
        
        // Convert markdown to HTML
        if (typeof marked !== 'undefined') {
            previewContent.innerHTML = marked.parse(content);
        } else {
            // Fallback if marked is not loaded
            previewContent.innerHTML = '<pre>' + content + '</pre>';
        }
        
        // Show modal
        var previewModal = new bootstrap.Modal(document.getElementById('previewModal'));
        previewModal.show();
    });
    
    // Save shortcut
    document.addEventListener('keydown', function(e) {
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            document.querySelector('form').submit();
        }
    });
});


document.getElementById('saveBtn').addEventListener('click', function () {
    // Make sure textarea is visible before submitting
    editor.textarea.style.display = 'block';
    editor.preview.style.display = 'none';

    // Submit the form
    document.querySelector('form').requestSubmit();
});


</script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Select all popups
        var popups = document.querySelectorAll('.imagepopup, .linkpopup, .tablepopup');
        // Loop through each popup and add a click event to its close button
        popups.forEach(popup => {
            var closeButton = popup.querySelectorAll('.fa-x, .fa-solid fas fa-x'); // Select the 'x' button inside the popup
            closeButton.forEach(closeBtn => {
                closeBtn.addEventListener('click', () => {
                popup.style.display = 'none'; // Hide the popup
                document.querySelector('.overlay').style.display = 'none'; // Show the overlay
                });
            })
        });
    });
    var selectElement = document.getElementById("headingDropdown");
    var toolbarImages = document.querySelectorAll(".toolbar img");
    var previewDiv = document.getElementById("preview");
    // Function to check if preview is visible and disable/enable interactions
    function toggleInteractions() {
        var isPreviewVisible = previewDiv.style.display === "block";
        selectElement.disabled = isPreviewVisible;
        toolbarImages.forEach(img => {
            if (img.id === "viewSourceBtn") {
                // Keep "View Source" clickable
                img.style.pointerEvents = "auto";
                //img.style.opacity = "1"; // Reset opacity
            } else {
                // Disable all other images
                img.style.pointerEvents = isPreviewVisible ? "none" : "auto";
                //img.style.opacity = isPreviewVisible ? "0.5" : "1"; // Optional: Visual indication
            }
        });
    }
    var textarea = document.getElementById('material_content');
    var history = [];
    var redoHistory = [];
    textarea.addEventListener('input', () => {
      //history.push(textarea.value);  // Save the current state to history
      redoHistory = [];  // Clear the redo history after a new input
    });
    /*document.getElementById("ctable").addEventListener("click", () => {
       document.querySelector(".tablepopup").style.display = "flex";
       document.querySelector(".imagepopup").style.display = "none";
       document.querySelector(".linkpopup").style.display = "none";
       document.querySelector('.overlay').style.display = 'block'; // Show the overlay
    });*/
	/*document.getElementById("createTable").addEventListener("click", () => {
        var numRows = document.getElementById('numRows').value;
        var numCols = document.getElementById('numCols').value;
        if (!numRows && !numCols){
            return;
        }
        if (numRows && numCols) {
            var tableMarkdown = '| ' + '**Header** | '.repeat(numCols) + '\n';
            tableMarkdown += '| ' + '--- | '.repeat(numCols) + '\n';
            for (var i = 0; i < numRows; i++) {
                tableMarkdown += '|  ' + '   |  '.repeat(numCols) + '\n';
            }
        textarea.value += '\n' + tableMarkdown;
            document.querySelector(".tablepopup").style.display = "none";
            document.querySelector('.overlay').style.display = 'none';
        }
    });*/
    function toggleList(type) {
    var textarea = document.getElementById('material_content');
    textarea.focus();

    var start = textarea.selectionStart;
    var end = textarea.selectionEnd;
    var value = textarea.value;

    // Expand selection to whole lines
    var before = value.lastIndexOf('\n', start - 1) + 1;
    var after = value.indexOf('\n', end);
    if (after === -1) after = value.length;

    var selectedText = value.substring(before, after);
    var lines = selectedText.split('\n');

    var isUnordered = lines.every(line => line.trim().startsWith('- '));
    var isOrdered = lines.every(line => /^\d+\.\s/.test(line.trim()));

    var formattedLines;

    if (type === 'unordered') {
        if (isUnordered) {
            formattedLines = lines.map(line => line.replace(/^\s*-\s/, '')).join('\n');
        } else {
            formattedLines = lines
                .map(line => line.replace(/^\s*\d+\.\s*/, '').trim()) // remove ordered format
                .map(line => `- ${line}`)
                .join('\n');
        }
    } else if (type === 'ordered') {
        if (isOrdered) {
            formattedLines = lines.map(line => line.replace(/^\s*\d+\.\s*/, '')).join('\n');
        } else {
            formattedLines = lines
                .map(line => line.replace(/^\s*-\s*/, '').trim()) // remove unordered
                .map((line, index) => `${index + 1}. ${line}`)
                .join('\n');
        }
    }

    // Replace the full-line selection with formatted text
    textarea.setRangeText(formattedLines, before, after, 'end');

    // Restore cursor/selection
    textarea.selectionStart = before;
    textarea.selectionEnd = before + formattedLines.length;
}
    // Event listeners for list buttons
    document.getElementById('unorderedListBtn').addEventListener('click', () => {
        toggleList('unordered');
    });
    document.getElementById('orderedListBtn').addEventListener('click', () => {
        toggleList('ordered');
    });
</script>
<script>
    var MDEditor = function() {
        this.textarea = document.getElementById('material_content');
        this.preview = document.getElementById('preview');
        var render = () => {
            var html = this.textarea.value;
            html = html.replace(/^---[\s\S]+?---\s*/, '');
            html = html.replace(/(\*\*\*(.+?)\*\*\*)/g, "<strong><i>$2</i></strong>");
            html = html.replace(/(\*\*(.+?)\*\*)/g, "<strong>$2</strong>");
            html = html.replace(/(\*(.+?)\*)/g, "<i>$2</i>");
            html = html.replace(/(\_(.+?)\_)/g, "<u>$2</u>");
            html = functions.headingTags(html);
            html = functions.backQuote(html);
            html = functions.imageTag(html);
            html = functions.linkTag(html);
            html = functions.tableTag(html); // New function for table support
            html = functions.ulList(html);
            html = functions.olList(html);
            html = functions.mixedList(html);
            // html = functions.lineBreak(html);
            //html = functions.codeBlock(html);      // ← add this before inlineCodeTag
            //html = functions.inlineCodeTag(html);  // ← rename your original codeTag
            html = functions.codeBlock(html); // Code blocks first
            html = functions.codeTag(html);   // Then inline code (`...`)
            //html = functions.removeArrows(html);
            


            this.preview.innerHTML = html;
        }
        var functions = {
            headingTags: (html) => {
                html = html.replace(/###### (.+)/g, "<h6>$1</h6>"); 
                html = html.replace(/##### (.+)/g, "<h5>$1</h5>");
                html = html.replace(/#### (.+)/g, "<h4>$1</h4>");
                html = html.replace(/### (.+)/g, "<h3>$1</h3>");
                html = html.replace(/## (.+)/g, "<h2>$1</h2>");
                html = html.replace(/# (.+)/g, "<h1>$1</h1>");
                return html;
            },
            // lineBreak: (html) => {
            //         // Replace new lines that aren't followed by another tag or list item with <br>
            //         return html.replace(/\n(?!<\/?(ul|ol|li|h[1-6]|blockquote|table|tr|th|td|hr|img|a|code|pre))/g, "<br>");
            //     },
            removeArrows: (html) => {
                return html.replace(/[<>]/g, '');
            },
            backQuote: (html) => {
                return html.replace(/^\> (.+)/gm, "<blockquote>$1</blockquote>");
            },
            codeBlock: (html) => {
                return html.replace(/```(?:\w+)?\s*\n([\s\S]*?)\n?```(?:\r?\n)?/g, (match, code) => {
                    const escapedCode = code
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;");
                    return `<div style="background-color: lightgrey;padding: 1em;">
                        <custompre><customcode>${escapedCode}</customcode></custompre>
                        </div>\n`;
                });
            },
            codeTag: (html) => {
                return html.replace(/\`(.+?)\`/g, "<code>$1</code>");
            },
            inlineCodeTag: (html) => {
                return html.replace(/`(.+?)`/g, "<code style='background-color: rgba(0,0,0,0.05); padding: 0 4px;'>$1</code>");
            },
            horizontalRule: (html) => {
                return html.replace(/---/g, "<hr>");
            },
            imageTag: (html) => {
                return html.replace(/\!\[(.+?)\]\((.+?)\)/g, `<img src="$2" alt="$1"/>`);
            },
            linkTag: (html) => {
                return html.replace(/\[(.+?)\]\((.+?)\)/g, `<a href="$2" target="_blank">$1</a>`);
            },
            ulList: (html) => {
                html = html.replace(/(?:^|\n)(\s*)- (.+)/g, (match, spaces, content) => {
                    var level = spaces.length / 2; // Determine the nesting level
                    var openTags = "<ul>".repeat(level + 1);
                    var closeTags = "</ul>".repeat(level + 1);
                    return `${openTags}<li>${content}</li>${closeTags}`;
                });
                // Remove overlapping </ul><ul> tags between nested levels
                html = html.replace(/<\/ul><ul>/g, "");
                html = html.replace(/<\/li><ul><li>/g, "<ul><li>");
                return html;
            },

            olList: (html) => {
                html = html.replace(/(?:^|\n)(\s*)(\d+\.|[a-zA-Z]\.|[ivxIVX]+\.) (.+)/g, (match, spaces, marker, content) => {
                    var level = spaces.length / 2; // Determine nesting level
                    var openTags = "<ol>".repeat(level + 1);
                    var closeTags = "</ol>".repeat(level + 1);
                    return `${openTags}<li>${content}</li>${closeTags}`;
                });
                // Remove overlapping </ol><ol> tags between nested levels
                html = html.replace(/<\/ol><ol>/g, "");
                html = html.replace(/<\/li><ol><li>/g, "<ol><li>");
                return html;
            },

            // Combined handler to support mixed lists
            mixedList: (html) => {
                html = html.replace(/(?:^|\n)(\s*)(- |\d+\.|[a-zA-Z]\.|[ivxIVX]+\.) (.+)/g, (match, spaces, marker, content) => {
                    var isOrdered = /\d+\.|[a-zA-Z]\.|[ivxIVX]+\./.test(marker);
                    var level = spaces.length / 2; // Determine nesting level
                    var openTags = isOrdered ? "<ol>".repeat(level + 1) : "<ul>".repeat(level + 1);
                    var closeTags = isOrdered ? "</ol>".repeat(level + 1) : "</ul>".repeat(level + 1);
                    return `${openTags}<li>${content}</li>${closeTags}`;
                });
                // Remove overlapping tags between nested levels
                html = html.replace(/<\/ul><ul>/g, "").replace(/<\/ol><ol>/g, "");
                html = html.replace(/<\/li><ul><li>/g, "<ul><li>").replace(/<\/li><ol><li>/g, "<ol><li>");
                return html;
            },
            tableTag: (html) => {
                var lines = html.split("\n");
                var result = "";
                var inTable = false;
                lines.forEach((line, index) => {
                    // Check if the line contains a table row by checking for "|" and ignore separator rows (e.g., "| --- |")
                    if (line.trim().startsWith("|") && line.trim().endsWith("|")) {
                        var cells = line.trim().split("|").slice(1, -1).map(cell => cell.trim());
                        // Skip row if all cells only contain hyphens (of any length)
                        var isSeparatorRow = cells.every(cell => /^-+$/.test(cell));
                        if (isSeparatorRow) return; // Skip separator row
                        // Detect header row by checking if it’s the first table row and is followed by a separator
                        var isHeaderRow = index > 0 && lines[index - 1].trim().match(/^\|\s*[-:]+\s*\|$/);
                        // Start table if it's the first row
                        if (!inTable) {
                            result += "<table><tbody>";
                            inTable = true;
                        }
                        // Add header or data rows
                        result += "<tr>";
                        var rowTag = isHeaderRow ? "th" : "td";
                        cells.forEach(cell => {
                            result += `<${rowTag}>${cell}</${rowTag}>`;
                        });
                        result += "</tr>";
                    } else {
                        // Close table if a non-table line is encountered after table rows
                        if (inTable) {
                            result += "</tbody></table>";
                            inTable = false;
                        }
                        result += line + "\n"; // Add non-table lines as is
                    }
                });
                // Close any remaining open table
                if (inTable) result += "</tbody></table>";
                return result;
            }
        }
        this.render = render;
    }
    var editor = new MDEditor();
    var viewSourceBtn = document.getElementById('viewSourceBtn');
    var viewPreviewBtn = document.getElementById('viewPreviewBtn');
    viewSourceBtn.addEventListener('click', () => {
        var previewDiv = document.getElementById('preview');
        var textarea = document.getElementById('material_content');

        // Function to convert HTML to Markdown
        function convertSelectedToMarkdown() {
            // Get the caret position and selection in the textarea
            var start = textarea.selectionStart;
            var end = textarea.selectionEnd;

            if (start === end) {
                // No text is selected; do nothing
                return;
            }

            // Get the selected text in the textarea
            var selectedText = textarea.value.substring(start, end);

            // Convert HTML-like text to Markdown
            var markdown = selectedText
                .replace(/<b>(.*?)<\/b>/g, '**$1**') // Bold to Markdown
                .replace(/<strong>(.*?)<\/strong>/g, '**$1**') // Strong to Markdown
                .replace(/<i>(.*?)<\/i>/g, '*$1*') // Italic to Markdown
                .replace(/<u>(.*?)<\/u>/g, '_$1_') // Underline to Markdown
                .replace(/<a href="(.*?)"[^>]*>(.*?)<\/a>/g, '[$2]($1)') // Links to Markdown
                .replace(/<ul>([\s\S]*?)<\/ul>/g, (match, listContent) => {
                    return listContent
                        .replace(/<li>(.*?)<\/li>/g, (_, listItem) => `- ${listItem.trim()}\n`)
                        .trim();
                })
                .replace(/<ol>([\s\S]*?)<\/ol>/g, (match, listContent) => {
                    var counter = 0;
                    return listContent
                        .replace(/<li>(.*?)<\/li>/g, (_, listItem) => `${++counter}. ${listItem.trim()}\n`)
                        .trim();
                })
                //.replace(/<br>/g, '\n') // Convert line breaks
                .replace(/<\/?[^>]+(>|$)/g, ''); // Remove any remaining HTML tags

            // Replace the selected text in the textarea with the Markdown
            textarea.setRangeText(markdown, start, end, 'end');
        }

        // Attach event listeners for bold, italic, etc., buttons
        document.querySelectorAll('.toolbar i[data-action]').forEach(button => {
            button.addEventListener('click', () => {
                var action = button.dataset.action;
                if (action === 'bold' || action === 'italic' || action === 'underline') {
                    convertSelectedToMarkdown(); // Convert selected text to Markdown
                }
            });
        });

        // Switch to source view
        textarea.style.display = 'block';
        previewDiv.style.display = 'none';
        selectElement.disabled = false; // Enable select dropdown
        toolbarImages.forEach(img => {
            img.style.pointerEvents = "auto";
        });
    });
    viewPreviewBtn.addEventListener('click', () => {
        editor.render();
        editor.textarea.style.display = 'none';
        editor.preview.style.display = 'block';
        toggleInteractions();
    });
    //var viewFileBtn = document.getElementById('viewFileBtn');
    var fileDiv = document.getElementById('file');
    var githubFileUrl = 'https://raw.githubusercontent.com/Birendra71/Dynamics/main/certifications/markdown123.md'; // replace with your GitHub file URL
    // var githubFileUrl = 'https://raw.githubusercontent.com/Birendra71/Dynamics/main/certifications/exam-duration-exam-experience.md';
    /*viewFileBtn.addEventListener('click', async () => {
	    console.log("clicked");
        try {
            refreshFileContent()
        }
        catch (error) {
        }
    });*/
    // Adding event listeners for toolbar icons
    document.querySelector(".imgBold").addEventListener("click", () => {
        wrapSelection("**");
    });
    document.querySelector(".imgItalic").addEventListener("click", () => {
        wrapSelection("*");
    });
    document.querySelector(".imgUnderline").addEventListener("click", () => {
        underlinewrapSelection("_");
    });
    /*document.querySelector(".imgImage").addEventListener("click", () => {
        document.querySelector(".imagepopup").style.display = "flex";
        document.querySelector(".linkpopup").style.display = "none";
        document.querySelector(".tablepopup").style.display = "none";
        document.querySelector('.overlay').style.display = 'block'; // Show the overlay
    });*/
    document.querySelector("#savepath").addEventListener("click", () => {
        var inputpath = document.getElementById('imagelink').value;
        var textarea = editor.textarea;
        var { selectionStart, selectionEnd, value } = textarea;
        var selectedText = value.slice(selectionStart, selectionEnd);
        console.log(selectedText);
        if (!inputpath){
            return;
        }
        if (inputpath && selectedText) {
            wrapSelectionWithImage(selectedText, inputpath);
        }
        document.querySelector(".imagepopup").style.display = "none";
        document.querySelector('.overlay').style.display = 'none';
    });
    function wrapSelectionWithLink(selectedText, url) {
        var textarea = editor.textarea;
        var { selectionStart, selectionEnd, value } = textarea;
        textarea.value = 
            value.slice(0, selectionStart) + 
            `[${selectedText}](${url})` + 
            value.slice(selectionEnd);
    }
    // ![Lose My Internet Connection](../images/lose-my-internet-connection.png)  
    function wrapSelectionWithImage(selectedText, inputpath){
        var textarea = editor.textarea;
        var { selectionStart, selectionEnd, value } = textarea;
        textarea.value = "!" + value.slice(0, selectionStart) + `[${selectedText}](${url})` + 
            value.slice(selectionEnd);
    }
    /*document.querySelector(".imgLink").addEventListener("click", () => {
        document.querySelector(".linkpopup").style.display = "flex";
        document.querySelector(".imagepopup").style.display = "none";
        document.querySelector(".tablepopup").style.display = "none";
        document.querySelector('.overlay').style.display = 'block'; // Show the overlay
    });*/
    document.querySelector("#savelink").addEventListener("click", () => {
        var inputlink = document.getElementById('linkin').value;
        var textarea = editor.textarea;
        var { selectionStart, selectionEnd, value } = textarea;
        var selectedText = value.slice(selectionStart, selectionEnd);
        console.log(selectedText);
        if (!inputlink){
            return;
        }
        if (inputlink && selectedText) {
            wrapSelectionWithLink(selectedText, inputlink);
        }
        document.querySelector(".linkpopup").style.display = "none";
        document.querySelector('.overlay').style.display = 'none';
    });
    // Heading dropdown listener
    document.getElementById("headingDropdown").addEventListener("change", (event) => {
        const selectedHeading = event.target.value;
        const { selectionStart, selectionEnd, value } = textarea;

        // Determine heading prefix
        let prefix = "";
        switch (selectedHeading) {
            case "heading1": prefix = "# "; break;
            case "heading2": prefix = "## "; break;
            case "heading3": prefix = "### "; break;
            case "heading4": prefix = "#### "; break;
        }

        // Find the start and end of the current line
        const lineStart = value.lastIndexOf('\n', selectionStart - 1) + 1;
        const lineEnd = value.indexOf('\n', selectionStart);
        const end = lineEnd === -1 ? value.length : lineEnd;

        let lineText = value.slice(lineStart, end);

        // Remove existing heading and leading spaces
        const leadingWhitespaceMatch = lineText.match(/^\s*/);
        const leadingWhitespaceLength = leadingWhitespaceMatch ? leadingWhitespaceMatch[0].length : 0;

        const cleanedLine = lineText.replace(/^(\s*)(#{1,4} )?/, '$1');

        // Build the new line with heading prefix
        const newLine = cleanedLine.slice(0, leadingWhitespaceLength) + prefix + cleanedLine.slice(leadingWhitespaceLength);

        // Reconstruct textarea content
        const newValue = value.slice(0, lineStart) + newLine + value.slice(end);
        textarea.value = newValue;

        // Adjust cursor position to after the heading
        const newCursor = lineStart + prefix.length;
        textarea.setSelectionRange(newCursor, newCursor);
        textarea.focus();
    });
    
    function removeHeadingPrefix() {
        var lines = textarea.value.split("\n").map(line => {
        // Remove heading if it starts with one to four '#' characters followed by a space
        return line.replace(/^(#{1,4} )/, "");
        });
        textarea.value = lines.join("\n");
    }

    // Final improved underlinewrapSelection using wrapper-style logic
// Final improved underlinewrapSelection using wrapper-style logic
// Final improved underlinewrapSelection using wrapper-style logic
// Updated underlinewrapSelection for precise selection trimming
// Updated underlinewrapSelection to maintain accurate selection range after removal
function underlinewrapSelection(wrapper) {
    const textarea = document.getElementById('material_content');
    textarea.focus();

    const { selectionStart, selectionEnd, value } = textarea;
    let selectedText = value.slice(selectionStart, selectionEnd);
    if (!selectedText) return;

    const leadingSpaces = selectedText.match(/^\s*/)?.[0] || '';
    const trailingSpaces = selectedText.match(/\s*$/)?.[0] || '';
    const trimmedText = selectedText.trim();

    let newContent;

    // === Regex to detect only markdown underline styling inside selection ===
    let innerMatch = trimmedText;
    let detectedUnderline = '';

    if (/^_{3}[^_]+_{3}$/.test(trimmedText)) {
        innerMatch = trimmedText.slice(3, -3);
        detectedUnderline = '___';
    } else if (/^_{2}[^_]+_{2}$/.test(trimmedText)) {
        innerMatch = trimmedText.slice(2, -2);
        detectedUnderline = '__';
    } else if (/^_[^_]+_$/.test(trimmedText)) {
        innerMatch = trimmedText.slice(1, -1);
        detectedUnderline = '_';
    } else {
        const outerMatch = value.slice(Math.max(0, selectionStart - 100), Math.min(value.length, selectionEnd + 100));
        const underlineWrapperRegex = /(_{1,3})(\*{0,3})([^_\n]+?)(\*{0,3})\1/g;

        for (const match of outerMatch.matchAll(underlineWrapperRegex)) {
            const full = match[0];
            const startIdx = value.indexOf(full);
            const innerText = match[3];
            const starsBefore = match[2];
            const starsAfter = match[4];
            const fullLength = full.length;

            if (selectionStart >= startIdx && selectionEnd <= startIdx + fullLength) {
                textarea.value = value.slice(0, startIdx) + starsBefore + innerText + starsAfter + value.slice(startIdx + fullLength);
                const newStart = startIdx + starsBefore.length;
                textarea.setSelectionRange(newStart, newStart + innerText.length);
                return;
            }
        }

        const styleMatch = trimmedText.match(/^(.*?)(_+[^_]+_+)(.*?)$/);
        if (styleMatch) {
            const prefix = styleMatch[1];
            const underlined = styleMatch[2];
            const suffix = styleMatch[3];

            const stripped = underlined.replace(/^_+/, '').replace(/_+$/, '');
            newContent = prefix + stripped + suffix;

            const finalText = leadingSpaces + newContent + trailingSpaces;
            const replacement = value.slice(0, selectionStart) + finalText + value.slice(selectionEnd);

            textarea.value = replacement;
            const newStart = selectionStart + prefix.length + leadingSpaces.length;
            textarea.setSelectionRange(newStart, newStart + stripped.length);
            return;
        }
    }

    // === CASE: Full wrapper match like _text_ ===
    if (detectedUnderline) {
        newContent = innerMatch;
        const finalText = leadingSpaces + newContent + trailingSpaces;

        textarea.value =
            value.slice(0, selectionStart) +
            finalText +
            value.slice(selectionEnd);

        const newStart = selectionStart + leadingSpaces.length;
        textarea.setSelectionRange(newStart, newStart + innerMatch.length);
        return;
    }

    // === Fallback: Check if wrapper exists around the text
    const pre = value.slice(selectionStart - wrapper.length, selectionStart);
    const post = value.slice(selectionEnd, selectionEnd + wrapper.length);
    if (pre === wrapper && post === wrapper) {
        textarea.value =
            value.slice(0, selectionStart - wrapper.length) +
            trimmedText +
            value.slice(selectionEnd + wrapper.length);

        textarea.setSelectionRange(
            selectionStart - wrapper.length,
            selectionStart - wrapper.length + trimmedText.length
        );
        return;
    }

    // === Apply new underline ===
    newContent = wrapper + trimmedText + wrapper;
    const finalText = leadingSpaces + newContent + trailingSpaces;

    textarea.value =
        value.slice(0, selectionStart) +
        finalText +
        value.slice(selectionEnd);

    const newStart = selectionStart + leadingSpaces.length;
    textarea.setSelectionRange(newStart, newStart + newContent.length);
    textarea.focus();
}







    function wrapSelection(wrapper) {
        const textarea = editor.textarea;
    const { selectionStart, selectionEnd, value } = textarea;

    let selectedText = value.slice(selectionStart, selectionEnd);
    if (!selectedText) return;

    const leadingSpaces = selectedText.match(/^\s*/)[0];
    const trailingSpaces = selectedText.match(/\s*$/)[0];
    const trimmedText = selectedText.trim();

    const isItalic = wrapper === '*';
    const isBold = wrapper === '**';

    let newContent;

    // === Regex to detect only markdown styling inside selection ===
    let innerMatch = trimmedText;
    let detectedStyle = '';
    let replaced = false;

    // Detect ***...***
    if (/^\*\*\*[^*]+\*\*\*$/.test(trimmedText)) {
        innerMatch = trimmedText.slice(3, -3);
        detectedStyle = 'bolditalic';
    } else if (/^\*\*[^*]+\*\*$/.test(trimmedText)) {
        innerMatch = trimmedText.slice(2, -2);
        detectedStyle = 'bold';
    } else if (/^\*[^*]+\*$/.test(trimmedText)) {
        innerMatch = trimmedText.slice(1, -1);
        detectedStyle = 'italic';
    } else {
        // ✅ Try to detect inline styles even if surrounded, like _***text***_
        const styleMatch = trimmedText.match(/^(.*?)(\*\*\*[^*]+\*\*\*|\*\*[^*]+\*\*|\*[^*]+\*)(.*?)$/);
        if (styleMatch) {
            const prefix = styleMatch[1];
            const styled = styleMatch[2];
            const suffix = styleMatch[3];

            if (/^\*\*\*[^*]+\*\*\*$/.test(styled)) {
                detectedStyle = 'bolditalic';
                innerMatch = styled.slice(3, -3);
                newContent = isBold ? `${prefix}*${innerMatch}*${suffix}` : `${prefix}**${innerMatch}**${suffix}`;
            } else if (/^\*\*[^*]+\*\*$/.test(styled)) {
                detectedStyle = 'bold';
                innerMatch = styled.slice(2, -2);
                if (isBold) {
                    newContent = `${prefix}${innerMatch}${suffix}`;
                } else {
                    newContent = `${prefix}***${innerMatch}***${suffix}`;
                }
            } else if (/^\*[^*]+\*$/.test(styled)) {
                detectedStyle = 'italic';
                innerMatch = styled.slice(1, -1);
                if (isItalic) {
                    newContent = `${prefix}${innerMatch}${suffix}`;
                } else {
                    newContent = `${prefix}***${innerMatch}***${suffix}`;
                }
            }

            if (newContent) {
                textarea.value =
                    value.slice(0, selectionStart) +
                    leadingSpaces + newContent + trailingSpaces +
                    value.slice(selectionEnd);

                const newLength = newContent.length + leadingSpaces.length + trailingSpaces.length;
                textarea.setSelectionRange(selectionStart, selectionStart + newLength);
                textarea.focus();
                return;
            }
        }
    }

    // Handle full trimmed match
    if (detectedStyle === 'bolditalic') {
        newContent = isBold ? `*${innerMatch}*` : `**${innerMatch}**`;
    } else if (detectedStyle === 'bold' && isBold) {
        newContent = innerMatch;
    } else if (detectedStyle === 'italic' && isItalic) {
        newContent = innerMatch;
    } else if (detectedStyle === 'bold' && isItalic) {
        newContent = `***${innerMatch}***`;
    } else if (detectedStyle === 'italic' && isBold) {
        newContent = `***${innerMatch}***`;
    } else if (detectedStyle === 'bolditalic' && isItalic) {
        newContent = `**${innerMatch}**`;
    } else if (detectedStyle === 'bolditalic' && isBold) {
        newContent = `*${innerMatch}*`;
    }

    if (newContent) {
        textarea.value =
            value.slice(0, selectionStart) +
            leadingSpaces + newContent + trailingSpaces +
            value.slice(selectionEnd);

        const newLength = newContent.length + leadingSpaces.length + trailingSpaces.length;
        textarea.setSelectionRange(selectionStart, selectionStart + newLength);
        textarea.focus();
        return;
    }


        // --- CASE: ***bold+italic*** toggle ---
        /*if (startsWith(trimmedText, fullBoldItalic)) {
            cleanText = strip(trimmedText, fullBoldItalic);
            newContent = isBold ? `*${cleanText}*` : `**${cleanText}**`; // toggle down
        }
        // --- CASE: **bold** toggle ---
        else if (startsWith(trimmedText, '**') && isBold) {
            cleanText = strip(trimmedText, '**');
            newContent = cleanText;
        }
        // --- CASE: *italic* toggle ---
        else if (startsWith(trimmedText, '*') && isItalic && !startsWith(trimmedText, '**')) {
            cleanText = strip(trimmedText, '*');
            newContent = cleanText;
        }
        // --- CASE: *italic* + Bold → make *** ---
        else if (startsWith(trimmedText, '*') && isBold && !startsWith(trimmedText, '**')) {
            cleanText = strip(trimmedText, '*');
            newContent = fullBoldItalic + cleanText + fullBoldItalic;
        }
        // --- CASE: **bold** + Italic → make *** ---
        else if (startsWith(trimmedText, '**') && isItalic) {
            cleanText = strip(trimmedText, '**');
            newContent = fullBoldItalic + cleanText + fullBoldItalic;
        }
        // --- CASE: ***text*** + Bold → reduce to *text* ---
        else if (startsWith(trimmedText, fullBoldItalic) && isBold) {
            cleanText = strip(trimmedText, fullBoldItalic);
            newContent = `*${cleanText}*`;
        }
        // --- CASE: ***text*** + Italic → reduce to **text** ---
        else if (startsWith(trimmedText, fullBoldItalic) && isItalic) {
            cleanText = strip(trimmedText, fullBoldItalic);
            newContent = `**${cleanText}**`;
        }*/
        else {

    const pre1 = value.slice(selectionStart - 1, selectionStart);
    const post1 = value.slice(selectionEnd, selectionEnd + 1);
    const pre2 = value.slice(selectionStart - 2, selectionStart);
    const post2 = value.slice(selectionEnd, selectionEnd + 2);
    const pre3 = value.slice(selectionStart - 3, selectionStart);
    const post3 = value.slice(selectionEnd, selectionEnd + 3);

    let isBoldItalicWrapped = false;
    let isBoldWrapped = false;
    let isItalicWrapped = false;

    if (pre3 === '***' && post3 === '***') {
        isBoldItalicWrapped = true;
    } else if (pre2 === '**' && post2 === '**') {
        isBoldWrapped = true;
    } else if (pre1 === '*' && post1 === '*') {
        isItalicWrapped = true;
    }

    const innerText = selectedText;

    // === BOLD WRAPPER CLICKED ===
    if (isBold) {
        if (isBoldItalicWrapped) {
            // ***text*** → Italic only
            textarea.value =
                value.slice(0, selectionStart - 3) +
                '*' + innerText + '*' +
                value.slice(selectionEnd + 3);

            textarea.setSelectionRange(
                selectionStart - 3,
                selectionStart - 3 + innerText.length + 2
            );
            textarea.focus();
            return;
        }
        if (isBoldWrapped) {
            // **text** → remove bold
            textarea.value =
                value.slice(0, selectionStart - 2) +
                innerText +
                value.slice(selectionEnd + 2);

            textarea.setSelectionRange(
                selectionStart - 2,
                selectionStart - 2 + innerText.length
            );
            textarea.focus();
            return;
        }
        if (isItalicWrapped) {
            // *text* + Bold → ***text***
            textarea.value =
                value.slice(0, selectionStart - 1) +
                '***' + innerText + '***' +
                value.slice(selectionEnd + 1);

            textarea.setSelectionRange(
                selectionStart - 1,
                selectionStart - 1 + innerText.length + 6
            );
            textarea.focus();
            return;
        }
    }

    // === ITALIC WRAPPER CLICKED ===
    if (isItalic) {
        if (isBoldItalicWrapped) {
            // ***text*** → Bold only
            textarea.value =
                value.slice(0, selectionStart - 3) +
                '**' + innerText + '**' +
                value.slice(selectionEnd + 3);

            textarea.setSelectionRange(
                selectionStart - 3,
                selectionStart - 3 + innerText.length + 4
            );
            textarea.focus();
            return;
        }
        if (isItalicWrapped) {
            // *text* → remove italic
            textarea.value =
                value.slice(0, selectionStart - 1) +
                innerText +
                value.slice(selectionEnd + 1);

            textarea.setSelectionRange(
                selectionStart - 1,
                selectionStart - 1 + innerText.length
            );
            textarea.focus();
            return;
        }
        if (isBoldWrapped) {
            // **text** + Italic → ***text***
            textarea.value =
                value.slice(0, selectionStart - 2) +
                '***' + innerText + '***' +
                value.slice(selectionEnd + 2);

            textarea.setSelectionRange(
                selectionStart - 2,
                selectionStart - 2 + innerText.length + 6
            );
            textarea.focus();
            return;
        }
    }

    // === Fallback: Not styled → Apply wrapper ===
    newContent = wrapper + trimmedText + wrapper;
            
        
        }

        // ✅ Replace with new content
        textarea.value =
            value.slice(0, selectionStart) +
            leadingSpaces + newContent + trailingSpaces +
            value.slice(selectionEnd);

        const newLength = (textarea.value.length - value.length) + (selectionEnd - selectionStart);
        textarea.setSelectionRange(selectionStart, selectionStart + newLength);
        textarea.focus();
    }
    function wrapSelectionWithLink(selectedText, url) {
        var textarea = editor.textarea;
        var { selectionStart, selectionEnd, value } = textarea;
        textarea.value = 
            value.slice(0, selectionStart) + 
            `[${selectedText}](${url})` + 
            value.slice(selectionEnd);
    }
    function prependSelection(prefix) {
        var textarea = editor.textarea;
        var { selectionStart, selectionEnd, value } = textarea;
        var selectedText = value.slice(selectionStart, selectionEnd);
        textarea.value = value.slice(0, selectionStart) + prefix + selectedText + value.slice(selectionEnd);
    }
    // Apply unordered or ordered list to the selected text or current line
    function applyList(type) {
        var textarea = document.getElementById('material_content');
        var start = textarea.selectionStart;
        var end = textarea.selectionEnd;
        var value = textarea.value;
        var before = value.substring(0, start);
        var selected = value.substring(start, end);
        var after = value.substring(end);
        if (selected.trim()) { // Text is selected
            var lines = selected.split('\n');
            var formattedLines;
            formattedLines = lines.map((line, index) => {
                var trimmed = line.trim();
                // Remove any existing list marker
                var withoutMarker = trimmed.replace(/^(?:- |\d+\. )/, '');
                if (type === 'unordered') {
                    return withoutMarker ? `- ${withoutMarker}` : "";
                } else { // Ordered
                    return withoutMarker ? `${index + 1}. ${withoutMarker}` : "";
                }
            });
            selected = formattedLines.join('\n');
            textarea.value = before + selected + after;
            textarea.selectionStart = start;
            textarea.selectionEnd = start + selected.length;
        } else { // No text is selected (Cursor on a line)
            var lines = value.split('\n');
            var cursorLineIndex = before.split('\n').length - 1;
            var line = lines[cursorLineIndex];
            var trimmed = line.trim();
            // Remove any existing list marker
            var withoutMarker = trimmed.replace(/^(?:- |\d+\. )/, '');
            var newListText;
            if (type === 'unordered') {
                newListText = withoutMarker ? `- ${withoutMarker}` : "- ";
            } else { // Ordered
                newListText = withoutMarker ? `1. ${withoutMarker}` : "1. ";
            }
            lines[cursorLineIndex] = newListText;
            textarea.value = lines.join('\n');
            textarea.selectionStart = textarea.selectionEnd = start + newListText.length - trimmed.length;
        }
    }
    // Event listeners for the buttons
    //    document.getElementById('unorderedListBtn').addEventListener('click', () => {
    //         applyList('unordered');
    //     });
    //     document.getElementById('orderedListBtn').addEventListener('click', () => {
    //         applyList('ordered');
    //     });
    document.getElementById('increaseIndentBtn').addEventListener('click', () => {
    var textarea = document.getElementById('material_content');
    var start = textarea.selectionStart;
    var end = textarea.selectionEnd;
    var lines = textarea.value.split('\n');

    var startLine = textarea.value.substring(0, start).split('\n').length - 1;
    var endLine = textarea.value.substring(0, end).split('\n').length - 1;

    // Indent each selected line
    for (var i = startLine; i <= endLine; i++) {
        lines[i] = `  ${lines[i]}`;
    }

    // Update the content
    textarea.value = lines.join('\n');

    // Recalculate new selection positions
    if (start === end) {
        // Cursor only, move it forward by 2
        var newCursorPos = start + 2;
        textarea.setSelectionRange(newCursorPos, newCursorPos);
    } else {
        // Text was selected
        var newStart = start + 2;
        var newEnd = end + (endLine - startLine + 1) * 2;
        textarea.setSelectionRange(newStart, newEnd);
    }

    // Restore focus
    textarea.focus();
});

</script>
<script>
    function replaceLiteralWithActual(target, find, replaceWith) {
        var content = target.value;
        var updatedContent = content.replaceAll(find, replaceWith);
        target.value = updatedContent;
        target.focus();
    }

    document.getElementById("insertNewlineBtn").addEventListener("click", function () {
        var textarea = document.getElementById("material_content");
        replaceLiteralWithActual(textarea, "\\n", "\n"); // replace literal \n with actual newline
        replaceLiteralWithActual(textarea, "\\t", "    "); // replace literal \t with 4 spaces
        replaceLiteralWithActual(textarea, "<", "");          // Remove <
        replaceLiteralWithActual(textarea, ">", "");  
       textarea.value = textarea.value.replace(/(^|\s)\*(\s|$)/g, function (match, p1, p2) {
        return p1 + '-' + p2;
    }); // Replace standalone * with -
    });

    
</script>

<script>
window.onload = function () {
    var textarea = document.getElementById("material_content");
    var rawJson = textarea.value;

    try {
        var parsed = JSON.parse(rawJson);

        // Define all possible keys based on the page context
        var possibleKeys = [
            "main_content",
            "comprehensive_lesson_plan",
            "comprehensive_activities",
            "comprehensive_assessments",
            "comprehensive_instructor_guide"
        ];

        // Try to find the first existing key
        var content = "";
        for (var key of possibleKeys) {
            if (parsed[key]) {
                content = parsed[key];
                 // Special case: if the key is comprehensive_lesson_plan, also append practice_questions
                if (key === "comprehensive_assessments" && parsed["practice_questions"]) {
                    content += "\n\n" + parsed["practice_questions"];
                }
                break;
            }
        }

        // Only update the textarea if content was found
        if (content) {
            // Unescape newlines and tabs
            content = content.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
            textarea.value = content;
        } else {
            console.warn("No matching content key found in JSON.");
        }

    } catch (err) {
        console.error("Error parsing JSON from textarea:", err);
    }
};
</script>


 <script>
            "use strict";
           // var globalContext = window.parent.Xrm.Utility.getGlobalContext();
            var githubConfig = {};
            var caseTitle = "";
            var fileName = "";
            
            function getQueryStringParameter(param) {
                var params = new URLSearchParams(window.location.search);
                return params.get(param);
            }
            
            var content = "";
            
            /*async function fetchGitHubConfig() {
                try {
                    const response = await window.parent.Xrm.WebApi.retrieveMultipleRecords("webresource", "?$filter=name eq 'new_githubnames'&$select=content");
            
                    if (response.entities.length > 0) {
                        const base64Content = response.entities[0].content;
                        const xmlString = atob(base64Content);
                        parseXMLConfig(xmlString);
                    } else {
                        console.warn("No web resource found with the name 'new_githubnames'.");
                    }
                } catch (error) {
                    console.error("Error fetching XML config:", error);
                }
            }*/
            
            function parseXMLConfig(xmlString) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            
                githubConfig.token = xmlDoc.getElementsByTagName("githubToken")[0].textContent;
                githubConfig.baseURL = xmlDoc.getElementsByTagName("githubBaseURL")[0].textContent;
                githubConfig.owner = xmlDoc.getElementsByTagName("owner")[0].textContent;
                githubConfig.repoName = xmlDoc.getElementsByTagName("repoName")[0].textContent;
                githubConfig.gitPreviewBranch = xmlDoc.getElementsByTagName("gitPreviewBranch")[0].textContent;
            
                console.log("GitHub config loaded:", githubConfig);
                setCaseTitleAndFileName();
            }

            function setCaseTitleAndFileName() {
                var data = getQueryStringParameter("data");
                if (data) {
                    try {
                        var caseData = JSON.parse(decodeURIComponent(data));
                        caseTitle = caseData.caseTitle || "";
                        fileName = caseTitle ? `${caseTitle.replace(/[^a-zA-Z0-9]/g, '-')}.md` : "";
                    } catch (e) {
                        console.error("Error parsing JSON:", e);
                    }
                }
            }
            
            function displayMarkdownContent() {
                var data = getQueryStringParameter("data");
                if (data) {
                    try {
                        var caseData = JSON.parse(decodeURIComponent(data));
                        content = caseData.content || "";
                        document.getElementById('material_content').value = content;
                        console.log("content: ", content);
                    } catch (e) {
                        console.error("Error parsing JSON: ", e);
                    }
                }
            }
            
            function saveMarkdownContent() {
                var data = getQueryStringParameter("data");
                if (data) {
                    try {
                        var caseData = JSON.parse(decodeURIComponent(data));
                        content = caseData.content || "";
                        caseTitle = caseData.caseTitle || "";
                        const markdownContent = document.getElementById('material_content').value;
                        console.log(caseTitle, markdownContent);
            
                        updateGitHubFile(caseTitle, markdownContent);
                    } catch (e) {
                        console.error("Error parsing JSON: ", e);
                    }
                }
            }

            async function updateGitHubFile(caseTitle, markdownContent) {
                if (!caseTitle) {
                    console.error("Case title is missing.");
                    return;
                }

                const fileName = `${caseTitle.replace(/[^a-zA-Z0-9]/g, '-')}.md`;
                const filePath = `certifications/${fileName}`;
                const commitMessage = `Updating ${fileName}`;
                
                try {
                    // Get the current file SHA to update it
                    const getFileResponse = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repoName}/contents/${filePath}`, {
                        headers: {
                            'Authorization': `Bearer ${githubConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    let sha = "";
                    if (getFileResponse.ok) {
                        const fileData = await getFileResponse.json();
                        sha = fileData.sha; // Get existing file SHA for update
                    }

                    const contentBase64 = btoa(unescape(encodeURIComponent(markdownContent))); // Encode to Base64

                    const response = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repoName}/contents/${filePath}`, {
                        method: "PUT",
                        headers: {
                            'Authorization': `Bearer ${githubConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: commitMessage,
                            content: contentBase64,
                            sha: sha || undefined // If the file exists, send SHA for update
                        })
                    });

                    if (response.ok) {
                        console.log(`Successfully updated: ${fileName}`);
                    } else {
                        console.error("Error updating file:", await response.json());
                    }
                } catch (error) {
                    console.error("Error in updateGitHubFile:", error);
                }
            }
            
            async function refreshFileContent() {
                if (!caseTitle || !fileName) {
                    console.error("Invalid case title or file name.");
                    return;
                }

                const filePath = `certifications/${fileName}`;
                const query = `{
                    repository(owner: "${githubConfig.owner}", name: "${githubConfig.repoName}") {
                        object(expression: "${githubConfig.gitPreviewBranch}:${filePath}") {
                            ... on Blob {
                                text
                            }
                        }
                    }
                }`;
                
                try {
                    const response = await fetch('https://api.github.com/graphql', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${githubConfig.token}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ query }),
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.data.repository.object) {
                            document.getElementById('material_content').value = data.data.repository.object.text;
                            console.log("File content refreshed:", data.data.repository.object.text);
                        } else {
                            console.error("File not found in repository.");
                        }
                    } else {
                        console.error('Error fetching file:', response.statusText);
                    }
                } catch (error) {
                    console.error("Error fetching GitHub file:", error);
                }
            }
            
            // Call to fetch GitHub configuration when the script loads
            //fetchGitHubConfig().then(refreshFileContent);
            console.log("load");
        </script>
{% endblock %}
